#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     0x01C00                ; Start of RAM        ORG     1C00

;Digits           0    1    2   3    4    5    6    7    8    9

digitH  db      0xFC,0x60,0xDB,0xF3,0x67,0xB7,0xBF,0xE0,0xFF,0xF7
digitL  db      0x28,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
disp    dW      0xA29,0xA25,0xA23,0xA29,0xA25,0xA23
Final   dw      0xA29,0xA25,0xA23,0xA32,0xA2E,0xA27

;operators        +     -    *     /
operHB  db      0x03, 0x03, 0x03, 0x00
operLB  db      0x50, 0x00, 0xFA, 0x28
      

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment



init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        mov.w   #0xFFFF,&LCDCPCTL0      ;Enable LCD segments 0-21; 26-43
        mov.w   #0xFC3F,&LCDCPCTL1
        mov.w   #0x0FFF,&LCDCPCTL2
        
        mov.w   #0,R9                   ; Temp input number                  
        mov.w   #0,R10                  ; First input number
        mov.w   #0,R11                  ; Second input number
        mov.w   #1,R12                  ; Mult. Counter (start at 1)
        mov.w   #0,R13                  ; Flag -> change if a number has been added

SetupP1:
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down

        
        
UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings
        mov.w   #0x041e,&LCDCCTL0
        mov.w   #0x0208,&LCDCVCTL
        mov.w   #0x8000,LCDCCPCTL
        mov.w   #2,&LCDCMEMCTL
        
        ;Turn LCD on
        Bis.w   #1,&LCDCCTL0
        
        mov.w #disp,R14
        mov.w @R14,R8
        mov.b #0,R5
        mov.w #0,R7
        mov.W #0xFFFF,R7
        
Mainloop:
         
        mov.b  digitH(R5),0(R8)
        mov.b  digitL(R5),1(R8)
        
        call    #waitingTime
    
        mov.b   &P1IN,R4
        
        ;Press left button
        and.b   #00000110B,R4
        cmp.b   #00000100B,R4
        jeq     nextNumber
        
        ;Press right button
        cmp.b   #00000010B,R4
        jeq     reset
        
        
        jmp     Mainloop 
        
reset:
        cmp     #0xA23,R8
        jz      tNumSel
        incd.w  R14
        mov.w   @R14,R8
        call    #updateNumber
        mov.b   #0,R5  
        
        jmp     Mainloop

updateNumber:
        add     R5,R11                  ; Add current number to result
        mov.w   R11,R9                  ; Update value to be multiplied * 10
        call    #timesTen               ; Multiply result by 10 (add 0 to the right)
        ret
        

timesTen:
        Add     R9,R11                   ; Add temp value to R6 repeated 10 times
        INC     R12                      
        CMP     #10,R12                  ; If R4 reaches 10, stop loop
        JNE     timesTen
        MOV     #1,R12
        RET

nextNumber:
        inc     R5
        cmp     #10,R5
        jz      returnZero
        jmp     Mainloop
        
returnZero:
        mov.b   #0,R5
        jmp     Mainloop
        
tNumSel:
        mov.b   #0, &0xA29
        mov.b   #0, &0xA25
        mov.b   #0, &0xA23
        add     R5,R11                  ; Add current number to result
        mov.w   #0,R9                   ; Update value to be multiplied * 10
        mov.b   #0,R5 
        CMP     #0,R13
        JNZ     switchStatement
        ;mov.w   #operHB,R14
        ;mov.w   @R14,R8
        ;mov.w   #operLB,R14
        ;mov.w   @R14,R9
        
MainOp:
        MOV.W   #2,&LCDCMEMCTL
        mov.b   operHB(R5),&0xA29
        mov.b   operLB(R5),&0xA2A
        
        
        call    #waitingTime
    
        mov.b   &P1IN,R4
        
        ;Press left button
        and.b   #00000110B,R4
        cmp.b   #00000100B,R4
        jeq     nextOp
        
        ;Press right button
        cmp.b   #00000010B,R4
        jeq     resetOp
        
        jmp     MainOp 
        
resetOp:
        mov.b   R5,R15                 ; Save index of operation chosen 
        mov.b   #0,R5
        incd.w  R14
        mov.w   @R14,R8
        mov.b   #0, &0xA29
        mov.b   #0,&0xA2A
        mov.w   R11,R10                ; Shift first value into R10
        mov.w   #0,R11                 ; Set space for second to 0
        inc     R13
        jmp     Mainloop
        
nextOp:
       
        inc     R5
        mov.b   operHB(R5),&0xA29
        mov.b   operLB(R5),&0xA2A
        cmp     #4,R5
        jz      returnOp
        jmp     MainOp
        
returnOp:
        mov.b   #0,R5
        jmp     MainOp
        mov.b   operHB(R5),&0xA29
        mov.b   operLB(R5),&0xA2A
        
waitingOp:
        dec.w    R7
        cmp.w   #0,R7    
        jnz     waitingOp
        mov.b   &P1IN,R4
        ret

waitingTime:
        dec.w    R7
        cmp.w   #0,R7    
        jnz     waitingTime
        mov.b   &P1IN,R4
        ret
        
; Switch statement to call operation subroutine based on the operand picked
switchStatement:
        CMP     #0,R15
        JEQ     addition
        CMP     #1,R15
        JEQ     subtract
        CMP     #2,R15
        JEQ     multSetUp
        CMP     #3,R15
        JEQ     divide        
        
        
addition:
        ADD     R10,R7
        ADD     R11,R7
        JMP     pushAndCallDisplay
        
subtract:
        SUB     R11,R10
        MOV.W   R10,R7
        JMP     pushAndCallDisplay
        
multSetUp:
        MOV.W   #0,R7          
        MOV.W   #0,R8       
        CMP.W   R10,R11                 ;Check to see which number is bigger
        JN      multFirstBigger         ;If R5 is bigger, add it R6 times
        JMP     multSecondBigger         ;Otherwise, add R6 R5 times
   
multFirstBigger:
        CMP     #0,R10                 ;Check to see if you've added the necessary amount of times
        JEQ     displayBothRegs                     
        DEC     R10                             
        ADD     R11,R8                 ;If not Add R8 again
        CMP     #1000,R8
        JGE     multFirstLeft
        JL      multFirstBigger
        
multFirstLeft:
        INC     R7
        SUB     #1000,R8     
        JMP     multFirstBigger
               
multSecondBigger:
        CMP     #0,R11
        JEQ     displayBothRegs      
        DEC     R11
        ADD     R10,R8
        CMP     #1000,R8
        JGE     multSecondLeft
        JL      multSecondBigger
        
multSecondLeft:
        INC     R7
        SUB     #1000,R8     
        JMP     multSecondBigger  

error:
       MOV.B    #0x9F, &0xA29
       MOV.B    #0xCF, &0xA25
       MOV.B    #0xCF, &0xA23
       MOV.B    #0xCF, &0xA2E
       MOV.B    #0x02, &0xA26
       MOV.B    #0x02, &0xA24
       MOV.B    #0x02, &0xA2F
       MOV.B    #0xFC, &0xA32
       JMP      pressToRepeatLoop
         
divide:
        CMP.W   #0,R11
        JEQ     error
        MOV.W   #0,R7                   ;Result
        MOV.W   #0,R8                   ;Remainder

divideLoop:
        MOV.W   R10,R8
        SUB.W   R11,R10                 ;Subtract denominator from numerator
        JN      pushAndCallDisplay                  ;If it's negative, end the division operation
        ;JZ      return
        INC     R7                      ;Increase result
        JMP     divideLoop              ;Loop again

displayBothRegs:  
        CMP     #0,R7
        JEQ     loadOne            
        JNE     loadBoth

loadOne:
        MOV     R8,R7
        JMP     pushAndCallDisplay
        
loadBoth:
        MOV.W   #1,R6                   ;Flag turns on if there's a second register to load
        MOV.W   R7,R14
        MOV.W   R8,R7
        JMP     pushAndCallDisplay

pushSecond:
        MOV.W   R14,R7
        MOV.w   #0,R6                   ;Turn off flag
        CMP     #100,R8
        JGE     displayResult
        CMP     #10,R8
        JGE     pushCeroOnce              
        push.w  #0
        push.w  #0
        JMP     displayResult
        
pushCeroOnce:
        push.w  #0
        JMP     displayResult

pushAndCallDisplay:
        MOV.W   #2,&LCDCMEMCTL
        PUSH.W   #0x00CD        
        JMP displayResult
        
checkIfNegative:
        CMP     #0,R7
        MOV.B   #0x04,&0xA2A            ; Negative sign
        
displayResult:
        MOV.W   #0,R12                   ;Result
        MOV.W   #0,R13                   ;Remainder
        mov.w   #0,R15
        
displayDivide:
        MOV.W   R7,R13
        SUB.W   #10,R7                    ;Subtract denominator from numerator
        JN      nextRemainder             ;If it's negative, end the division operation
        INC     R12                       ;Increase result
        JMP     displayDivide             ;Loop again

nextRemainder:
        mov     R12,R7
        push.w  R13
        cmp     #0,R12
        jnz     displayResult
        mov.b   #0,R4
        mov.w   #Final,R4
        jz      checkFlag
        
        
checkFlag:
        CMP     #1,R6
        JEQ     pushSecond
        JNE     mostrarD
   
mostrarD:
        mov.w   @R4,R13
        Pop.w   R5     
        cmp.b   #0x00CD,R5
        JEQ     pressToRepeatLoop
        ;JZ      return
        mov.b  digitH(R5),0(R13)
        mov.b  digitL(R5),1(R13)
        incd.w  R4
        jmp     mostrarD        

return:
        RET
        
;Repeats until the user presses any of the two buttons used throughout the progam again.
;When the user does so, it jumps to the next Subroutine that clears the display and 
;restarts the program.
pressToRepeatLoop:
        call    #waitingTime
    
        mov.b   &P1IN,R4
        
        ;Press left button
        and.b   #00000110B,R4
        cmp.b   #00000100B,R4
        jeq     init
        
        ;Press right button
        cmp.b   #00000010B,R4
        jeq     init
        JMP     pressToRepeatLoop
        
;Clears numbers in the display and goes back to the beginning of the program
pressToRepeat:
              MOV.W   #2,&LCDCMEMCTL
              JMP        init
       
overSubroutine:
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        END
